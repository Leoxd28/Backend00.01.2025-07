const express = require('express');
const { body, query, validationResult } = require('express-validator');
const { Course, User, Lesson, Enrollment } = require('../models');
const { Op } = require('sequelize');

const router = express.Router();

// Validation middleware
const handleValidationErrors = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            error: 'Validation Error',
            details: errors.array()
        });
    }
    next();
};

// POST /api/courses - Create course (instructor/admin only)
router.post('/', [
    body('title')
        .trim()
        .isLength({ min: 5, max: 255 })
        .withMessage('Title must be between 5 and 255 characters'),
    body('description')
        .optional()
        .trim(),
    body('ownerId')
        .isInt({ min: 1 })
        .withMessage('Owner ID must be a valid user ID'),
    body('published')
        .optional()
        .isBoolean()
        .withMessage('Published must be a boolean')
], handleValidationErrors, async (req, res) => {
    try {
        const { title, description, ownerId, published = false } = req.body;

        // Verify owner exists and is instructor/admin
        const owner = await User.findByPk(ownerId);
        if (!owner) {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Owner user not found'
            });
        }

        if (!['instructor', 'admin'].includes(owner.role)) {
            return res.status(403).json({
                error: 'Forbidden',
                message: 'Only instructors and admins can create courses'
            });
        }

        // Create course (slug will be auto-generated by hook)
        const course = await Course.create({
            title,
            description,
            published,
            ownerId
        });

        console.log(`âœ… [courses] Course created: ${course.title} by ${owner.email}`);

        // Return course with owner info
        const courseWithOwner = await Course.findByPk(course.id, {
            include: [{
                model: User,
                as: 'owner',
                attributes: ['id', 'firstName', 'lastName', 'email']
            }]
        });

        res.status(201).json({
            message: 'Course created successfully',
            course: courseWithOwner
        });

    } catch (error) {
        console.error('âŒ [courses] Error creating course:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: error.message
        });
    }
});

// GET /api/courses - List courses with filters
router.get('/', [
    query('published').optional().isBoolean().toBoolean(),
    query('q').optional().trim(),
    query('order').optional().isIn(['createdAt:DESC', 'createdAt:ASC', 'title:ASC', 'title:DESC']),
    query('page').optional().isInt({ min: 1 }).toInt(),
    query('pageSize').optional().isInt({ min: 1, max: 100 }).toInt()
], handleValidationErrors, async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 10;
        const published = req.query.published;
        const q = req.query.q?.trim();
        const orderParam = req.query.order || 'createdAt:DESC';

        // Parse order parameter
        const [orderField, orderDirection] = orderParam.split(':');
        
        // Build where conditions
        const where = {};
        
        if (typeof published === 'boolean') {
            where.published = published;
        }

        if (q) {
            where[Op.or] = [
                { title: { [Op.like]: `%${q}%` } },
                { description: { [Op.like]: `%${q}%` } }
            ];
        }

        // Execute query
        const { rows: courses, count } = await Course.findAndCountAll({
            where,
            include: [
                {
                    model: User,
                    as: 'owner',
                    attributes: ['id', 'firstName', 'lastName']
                }
            ],
            order: [[orderField, orderDirection]],
            limit: pageSize,
            offset: (page - 1) * pageSize
        });

        console.log(`ğŸ“š [courses] Listed ${courses.length}/${count} courses (page ${page})`);

        res.json({
            total: count,
            page,
            pageSize,
            totalPages: Math.ceil(count / pageSize),
            data: courses
        });

    } catch (error) {
        console.error('âŒ [courses] Error listing courses:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: error.message
        });
    }
});

// GET /api/courses/:slug - Get course by slug with stats
router.get('/:slug', async (req, res) => {
    try {
        const { slug } = req.params;

        const course = await Course.findOne({
            where: { slug },
            include: [
                {
                    model: User,
                    as: 'owner',
                    attributes: ['id', 'firstName', 'lastName', 'email']
                },
                {
                    model: Lesson,
                    as: 'lessons',
                    attributes: ['id', 'title', 'slug', 'order'],
                    order: [['order', 'ASC']]
                }
            ]
        });

        if (!course) {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Course not found'
            });
        }

        // Get enrollment statistics
        const studentsCount = await Enrollment.count({
            where: { 
                courseId: course.id,
                status: 'active'
            }
        });

        console.log(`ğŸ“– [courses] Course retrieved: ${course.title}`);

        res.json({
            ...course.toJSON(),
            stats: {
                lessonsCount: course.lessons.length,
                studentsCount
            }
        });

    } catch (error) {
        console.error('âŒ [courses] Error getting course:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: error.message
        });
    }
});

// PUT /api/courses/:id - Update course
router.put('/:id', [
    body('title')
        .optional()
        .trim()
        .isLength({ min: 5, max: 255 })
        .withMessage('Title must be between 5 and 255 characters'),
    body('description')
        .optional()
        .trim(),
    body('published')
        .optional()
        .isBoolean()
        .withMessage('Published must be a boolean')
], handleValidationErrors, async (req, res) => {
    try {
        const { id } = req.params;
        const updates = req.body;

        const course = await Course.findByPk(id);
        if (!course) {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Course not found'
            });
        }

        // Update course
        await course.update(updates);

        console.log(`âœï¸ [courses] Course updated: ${course.title}`);

        // Return updated course with owner
        const updatedCourse = await Course.findByPk(id, {
            include: [{
                model: User,
                as: 'owner',
                attributes: ['id', 'firstName', 'lastName']
            }]
        });

        res.json({
            message: 'Course updated successfully',
            course: updatedCourse
        });

    } catch (error) {
        console.error('âŒ [courses] Error updating course:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: error.message
        });
    }
});

// DELETE /api/courses/:id - Soft delete course
router.delete('/:id', async (req, res) => {
    try {
        const { id } = req.params;

        const course = await Course.findByPk(id);
        if (!course) {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Course not found'
            });
        }

        // Soft delete
        await course.destroy();

        console.log(`ğŸ—‘ï¸ [courses] Course soft deleted: ${course.title}`);

        res.json({
            message: 'Course deleted successfully'
        });

    } catch (error) {
        console.error('âŒ [courses] Error deleting course:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: error.message
        });
    }
});

module.exports = router;